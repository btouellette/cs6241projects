\documentclass{article}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{amstext}
\usepackage[left=1in,top=1in,right=1in,bottom=1in,nohead]{geometry}

\title{CS6241 Project Phase 1}

\author{Gaurav Gupta, Chad D. Kersey, Brian Ouellette}

\begin{document}

\maketitle

\section{Bounds Check Implementation}

Bounds checking was implemented in two pieces, one inside of the GCC frontend
marks the array accesses and exposes the bounds and index, and another inside of
LLVM takes these annotations and inserts checks. The checks inserted are 
one-sided unsigned comparisons. Since C and C++ arrays can have no starting
index other than zero, casting all indices to unsigned integers and checking the
index against the upper bound will always be sufficient.

\subsection{Modifications to GCC}

The heart of LLVM-GCC is a translator from GCC's IR into LLVM instructions, in
llvm-convert.cpp. 34 lines were added to this file, the modified version of 
which is included in the project submission under llvm-gcc. The lines in 
question are 458-491, in the function responsible for emitting LLVM code for 
array references. A pseudocode version of the added block is presented below:

\begin{verbatim}
  if indexed item is a global or on-stack array:
    upper_bound_cast_instruction = llvm_cast_to_uint64(upper_bound)
    index_cast_instruction = llvm_cast_to_uint64(index)
    
    insert_at_end_of_current_function(upper_bound_cast_instruction)
    insert_at_end_of_current_function(index_cast_instruction)
\end{verbatim}

The upper bound and index are already part of GCC's internal representation, 
GIMPLE, and are readily available as parameters to the indexing operation. The
two casts inserted have no uses and are present only to provide the 
InsertionChecks pass, described in the next Section, with the locations to place
checks and the values to use.

\subsection{InsertChecks Pass}

\begin{itemize}
\item In the LLVM pass, calls to into libCheck are added for every array.
\item To optimize these checks, the dummy instructions indicating their presence 
  must be moved before InsertChecks is run.
\end{itemize}

\subsection{Impact}

\begin{itemize}
\item LAME
\begin{itemize}
\item 6.0\% code size increase and 6.1\% execution time increase with no optimization.
\item Average of 5.97 bytes per bounds check.
\end{itemize}
\item mpeg2dec
\begin{itemize}
\item 97124 bytes - mpeg2dec-checked (3877495 total checks, 121 static)
\item 90900 bytes - mpeg2dec-unchecked
\end{itemize}
\end{itemize}

\section{Bounds Check Pruning}

\subsection{Constant Removal}

If both the array index and the upper bound are constants then the check can be performed at compile time. Checks that evaluate true are removed from the output code and checks that evaluate false are left in to potentially be revealed at run-time.

\subsection{Local Elimination}

The function is then examined on a basic block level and locally redundant checks are removed. A check is locally redundant if one that is at least as strict as it is performed earlier in the basic block. Since the checks utilized are one-sided comparisons on unsigned numbers some care must be taken when determining what is "more strict" as it depends on whether the upper bound and index are constants or SSA values. Checks are eliminated locally if there is a check with a lower upper bound and identical index or with identical upper bounds and an index between 0 and a previously checked index.

\subsection{Global Elimination}

Global elimination differs from Gupta's paper slightly as monotonicity is not involved and all values are SSA. The choice to use one-sided unsigned checks removes any potential for optimization through exploiting monotonically increasing or decreasing values; however, it reduces the number of checks required by half upfront which results in a number of checks as small as if every check can be exploited using monotonicity. The dataflow equations used to determine whether global elimination is feasible are given below.
\begin{eqnarray*}
C\_IN[B_{1}]&=&\phi\text{, where } B_{1} \text{ is the initial basic block}\\
C\_IN[B]&=&\cap C\_OUT[P]_{P\in Pred(B)}\text{, where Pred(B) is the set of basic blocks that are predecessors of B}\\
C\_OUT[B]&=&(C\_IN[B] - C\_KILL[B]) \cup C\_GEN[B]
\end{eqnarray*}

Since our target code is already translated to SSA the C\_KILL set will be empty in all situations and C\_GEN is simply the set of checks that are present in each basic block. The C\_IN and C\_OUT sets are computed iteratively until they have stabilized. Then each basic block is examined and any check inside is potentially eliminated by checks that are at least as strict and are present in the C\_IN set. "At least as strict" is implemented in the same way as for local elimination.

\subsection{Propagation of Checks Out of Loops}


\section{Further Bounds Check Pruning}

\subsection{Profiling Infrastructure in libCheck.cpp}

\begin{itemize}
\item Tracks address and 
\end{itemize}

\subsection{The Most Frequent Checks}

The profiling infrastructure, in combinantion with the GNU Debugger, discovered
that the most frequent checks occurred in the inner loop, lines 313 through 315 
of psymodel.c in the following loop:

\begin{verbatim}
308 for ( b = 0;b < npart_s; b++ ) {
309   FLOAT8 norm=0;
310   for ( k = s3ind_s[b][0]; k <= s3ind_s[b][1]; k++ ) {
311     norm += s3_s[b][k];
312   }
313   for ( k = s3ind_s[b][0]; k <= s3ind_s[b][1]; k++ ) {
314     s3_s[b][k] *= SNR_s[b] / norm;
315   }
316   /*printf("%i  norm=%f  norm_s=%f \n",b,1/norm,norm_l[b]);*/
317 }
\end{verbatim}

This single three-line inner loop accounts for 9.94 percent of total dynamic 
array bounds checks, and all of the frequent inner loops have similar form. 
Because b is bounded by npart\_s, which is loop invariant in the outer loop, and
k is  bounded by a value that is loop invariant in the inner loop, all of the 
checks can be hoisted to their respective loop headers as shown in Gupta, pages
145-149.

\subsection{Elimination of the Most Frequent Checks}

\end{document}